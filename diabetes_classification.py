# -*- coding: utf-8 -*-
"""diabetes-classification

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JrCnVAOopc9u7ZsktkGPb4zZUmi1mmUL
"""

import pandas as pd
import numpy as np
from sklearn import preprocessing
import matplotlib.pyplot as plt
plt.rc("font", size=14)
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
import seaborn as sns
sns.set(style="white")
sns.set(style="whitegrid", color_codes=True)



# Loading the data and removing any null attributes

#My dataset had a column called 'class' so I changed it to 'y'
data = pd.read_csv('https://diabetes-data-mka.s3.eu-west-2.amazonaws.com/diabetes_data_upload.csv', header=0)
data = data.dropna()
# Gives the shape of the panda array, (rows, cols) returned
print(data.shape)
print(list(data.columns))

# Show the first 5 elements in the dataset
data.head()

# Luckily our dataset does not have any attributes with too many columns, so I don't need to reduce it

# Data Exploration, class is our y variable so we need to see the distribution of +ve and -ve results
data['y'].value_counts()
sns.countplot(x='y', data=data, palette='hls')
plt.show()
plt.savefig('count_plot')

"""As you can see the number of people who are positive with diabeters is almost double that of negative, so our dataset is imbalanced. Must do something to balance this data out!"""

# Convert the 'positive' to 1 and 'negative' to 0
data.y.replace(('Positive', 'Negative'), (1, 0), inplace=True) #converting the data so its binary
data.head()

# Changing the 'Yes' to 1
data.replace('Yes', 1, inplace=True)

data.replace('No', 0, inplace=True)

data.head()

count_none_diab = len(data[data['y']==0])
count_diab = len(data[data['y']==1])
perc_of_none_diab = count_none_diab/(count_none_diab + count_diab)
print("Percentage of people without diabetes is", perc_of_none_diab*100)
perc_of_diab = count_diab/(count_none_diab + count_diab)
print("Percentage of diabetics", perc_of_diab*100)

"""Ratio of diabetics to none diabetics is 61:38"""

# Data exploration
# Our classes are imbalances, the ratio of no-subscription to subscription is 89:11, before we balance we need to do more exploration

data.groupby('y').mean()

"""Observations:
- The average age of patients with Diabetes is only higher than patients who don't
- Weirdly number of people with Alopecia are higher for people without diabetes, possible that this is not a factor of diabetes
"""

count_no_sub = len(data[data['y']==0])
count_sub = len(data[data['y']==1])
percentage_of_no_sub = count_no_sub/(count_no_sub+count_sub)
print("percentage of no subscription is", percentage_of_no_sub*100)
percentage_of_no_sub = count_sub/(count_no_sub+count_sub)
print("percentage of subscription", percentage_of_no_sub*100)

data.rename(columns={'sudden weight loss': 'WeightLoss', 'Genital thrush': 'GenitalThrush', 'visual blurring': 'VisualBlurring', 'delayed healing': 'DelayedHealing', 'partial paresis': 'PartialParesis', 'muscle stiffness': 'MuscleStiffness'}, inplace=True)

print(data.columns)

# Commented out IPython magic to ensure Python compatibility.
# Visualizations
# %matplotlib inline
# Age - Not a good indicator, too many categories, maybe join to age groups?
pd.crosstab(data.Age,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Age and Diabetes').set_color('white') # 2 - plot the title
plt.xlabel('Age').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_age') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Gender
pd.crosstab(data.Gender,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Gender and Diabetes').set_color('white') # 2 - plot the title
plt.xlabel('Age').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_gender') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Polyuria
# Not a good indicator because there isn't a clear indication of whether the symptom gives diabetes or not
pd.crosstab(data.Polyuria,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Polyuria and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Polyuria').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_Polyuria') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Polydipsia
pd.crosstab(data.Polydipsia,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Polydipsia and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Polydipsia').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_Polydipsia') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# WeightLoss
pd.crosstab(data.WeightLoss,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('WeightLoss and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('WeightLoss').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_weightloss') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# weakness
pd.crosstab(data.weakness,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('weakness and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('weakness').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_weakness') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Polyphagia
pd.crosstab(data.Polyphagia,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Polyphagia and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Polyphagia').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_polyphagia') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# GenitalThrush
pd.crosstab(data.GenitalThrush,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('GenitalThrush and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('GenitalThrush').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_genitalThrush') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# VisualBlurring 
pd.crosstab(data.VisualBlurring,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Visual Blurring and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Visual Blurring').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_visualBlurring') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Itching
pd.crosstab(data.Itching,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Itching and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Itching').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_Itching') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Irritability
pd.crosstab(data.Irritability,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Irritability and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Irritability').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_Irritability') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# DelayedHealing
pd.crosstab(data.DelayedHealing,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('DelayedHealing and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('DelayedHealing').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_delayedHealing') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# PartialParesis
pd.crosstab(data.PartialParesis,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('PartialParesis and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('PartialParesis').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_partialParesis') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# MuscleStiffness
pd.crosstab(data.MuscleStiffness,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('MuscleStiffness and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('MuscleStiffness').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_muscleStiffness') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Alopecia
pd.crosstab(data.Alopecia,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Alopecia and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Alopecia').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_alopecia') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Obesity
pd.crosstab(data.Obesity,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Obesity and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Obesity').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_obesity') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

"""Data Visualization Info

Age too many categories

Good indicators:
Polyuria and Polydipsia are the best indicators
"""

# Polyuria
# Not a good indicator because there isn't a clear indication of whether the symptom gives diabetes or not
pd.crosstab(data.Polyuria,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Polyuria and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Polyuria').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_Polyuria') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Polydipsia
pd.crosstab(data.Polydipsia,data.y).plot(kind='bar') # 1 - use pandas to determine the type of table, with x and y axis
plt.title('Polydipsia and Diabetics').set_color('white') # 2 - plot the title
plt.xlabel('Polydipsia').set_color('white') # 3 - Plot the x label
plt.ylabel('Frequency of Diabetics').set_color('white') # 4 - Plot the y label
plt.savefig('diabetics_Polydipsia') # 5 - Save the figure so it can be referenced later
#plt.axhline(color='white') change colour of the axis line
plt.tick_params(axis='x', colors='white') # ticks is what you call the labels
plt.tick_params(axis='y', colors='white')

# Better visualisation for age, can see most diabetics are in age range 40 - 60
data.Age.hist()
plt.title('Histogram of Age')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.savefig('hist_age')

# Create dummt variables, may already be in this form

cat_vars = ['Polyuria','Polydipsia']
for var in cat_vars:
    cat_list='var'+'_'+var
    cat_list = pd.get_dummies(data[var], prefix=var)
    data1=data.join(cat_list)
    data=data1

cat_vars = ['Polyuria','Polydipsia']
data_vars=data.columns.values.tolist()
to_keep=[i for i in data_vars if i not in cat_vars]

data_final=data[to_keep]
data_final.columns.values

data.head()
data.tail()

# Problem here - Male, 0 and Female, 1
data_final.replace('Female', 1, inplace=True)
data_final.replace('Male', 0, inplace=True)

data_final.head()

# Over-sample the data with SMOTE

X = data_final.loc[:, data_final.columns != 'y']
y = data_final.loc[:, data_final.columns == 'y']

from imblearn.over_sampling import SMOTE

os = SMOTE(random_state=0)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)
columns = X_train.columns
# This is where the data is split
os_data_X,os_data_y=os.fit_sample(X_train, y_train)
os_data_X = pd.DataFrame(data=os_data_X,columns=columns )
os_data_y= pd.DataFrame(data=os_data_y,columns=['y'])
# we can Check the numbers of our data
print("length of oversampled data is ",len(os_data_X))
print("Number of none diabetics in oversampled data",len(os_data_y[os_data_y['y']==0]))
print("Number of diabetics",len(os_data_y[os_data_y['y']==1]))
print("Proportion of none diabetics data in oversampled data is ",len(os_data_y[os_data_y['y']==0])/len(os_data_X))
print("Proportion of diabetics data in oversampled data is ",len(os_data_y[os_data_y['y']==1])/len(os_data_X))

"""Now we have a perfect balanced data! You may have noticed that I over-sampled only on the training data, because by oversampling only on the training data, none of the information in the test data is being used to create synthetic observations, therefore, no information will bleed from test data into the model training."""

# Recursive Feature Elimination

# The goal of RFE is to select features by recursively considering smaller and smaller sets of features
# based on the idea to repeatedly construct a model and choose either the best or worst performing feature, setting the feature aside and then repeating the process with the rest of the features

data_final_vars=data_final.columns.values.tolist()
y=['y']
X=[i for i in data_final_vars if i not in y]

from sklearn.feature_selection import RFE
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler

logreg = LogisticRegression(max_iter=10000) # fixed by increasing max number of iterations
rfe = RFE(logreg, 20)
rfe = rfe.fit(os_data_X, os_data_y.values.ravel())
print(rfe.support_)
print(rfe.ranking_)

print(data.columns)

# RFE has helped us choose the following columns, where all the values are True or 1 are the following columns
# Removes Polyuria and Polydipsia
cols=['Age', 'Gender', 'WeightLoss', 'weakness',
       'Polyphagia', 'GenitalThrush', 'VisualBlurring', 'Itching',
       'Irritability', 'DelayedHealing', 'PartialParesis', 'MuscleStiffness',
       'Alopecia', 'Obesity','Polyuria_0', 'Polyuria_1','Polydipsia_0',
       'Polydipsia_1'] 
X=os_data_X[cols]
y=os_data_y['y']

# Implementing the model

import statsmodels.api as sm
logit_model=sm.Logit(y,X)
result=logit_model.fit()
print(result.summary2())

cols=['Age', 'Gender', 'GenitalThrush', 'Itching', 'DelayedHealing',
       'Polydipsia_1'] 
X=os_data_X[cols]
y=os_data_y['y']
logit_model=sm.Logit(y,X)
result=logit_model.fit()
print(result.summary2())

# Logistic Regression Model Fitting - finally up to this part!

from sklearn.linear_model import LogisticRegression
from sklearn import metrics
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)
logreg = LogisticRegression()
logreg.fit(X_train, y_train)

y_pred = logreg.predict(X_test)
print('Accuracy of logistic regression classifier on test set: {:.2f}'.format(logreg.score(X_test, y_test)))

#New accuracy!!

from sklearn.metrics import confusion_matrix
confusion_matrix = confusion_matrix(y_test, y_pred)
print(confusion_matrix)

# The result is telling us that we have 63+57 correct predictions and 5+11 incorrect predictions.

"""- Stopped focuing from here, pick up from here!

Compute precision, recall, F-measure and support
"""

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred))

# ROC Curve

from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_curve
logit_roc_auc = roc_auc_score(y_test, logreg.predict(X_test))
fpr, tpr, thresholds = roc_curve(y_test, logreg.predict_proba(X_test)[:,1])
plt.figure()
plt.plot(fpr, tpr, label='Logistic Regression (area = %0.2f)' % logit_roc_auc)
plt.plot([0, 1], [0, 1],'r--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic')
plt.legend(loc="lower right")
plt.savefig('Log_ROC')
plt.show()

"""The receiver operating characteristic (ROC) curve is another common tool used with binary classifiers. The dotted line represents the ROC curve of a purely random classifier; a good classifier stays as far away from that line as possible (toward the top-left corner)."""